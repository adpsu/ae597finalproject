import pandas as pd
import numpy as np
import geopandas as gpd
import matplotlib.pyplot as plt
from matplotlib.colors import Normalize

# Step 1: Load US Counties Shapefile
shapefile_path = 'tl_2019_us_county.shp'  # Replace with the actual path
us_counties = gpd.read_file(shapefile_path)
us_counties['state'] = us_counties['GEOID'].str[:2]  # Extract state codes
us_counties = us_counties[['GEOID', 'geometry']].rename(columns={'GEOID': 'county'})

# Step 2: Generate synthetic dataset
np.random.seed(42)

# Generate timestamps
time_range = pd.date_range(start="2018-01-01 00:00:00", end="2018-12-31 23:00:00", freq="H")

# Generate random counties (FIPS codes: 5 digits)
counties = us_counties['county'].tolist()

# Create synthetic data
data = {
    "time_est": np.random.choice(time_range, size=100000),
    "county": np.random.choice(counties, size=100000),
    "value": np.random.uniform(1.0, 100.0, size=100000),
}
synthetic_df = pd.DataFrame(data)
synthetic_df["county"] = synthetic_df["county"].str.zfill(5)  # Ensure leading zeros
synthetic_df["state"] = synthetic_df["county"].str[:2]  # Extract state codes

# Step 3: Define resampling function
def resample_data(df, resolution):
    df['time_est'] = pd.to_datetime(df['time_est'])
    if resolution == 'hourly':
        return df
    elif resolution == 'weekly':
        df['time_est'] = df['time_est'].dt.to_period('W').dt.start_time
    elif resolution == 'monthly':
        df['time_est'] = df['time_est'].dt.to_period('M').dt.start_time
    return df

# Step 4: Aggregate data for each time resolution
time_resolutions = ['hourly', 'weekly', 'monthly']
spatial_resolutions = ['county', 'state', 'country']

# Initialize a dictionary for aggregated data
county_time_aggregates = {}

for time_res in time_resolutions:
    resampled_df = resample_data(synthetic_df.copy(), time_res)

    # Aggregate values by county and time resolution
    grouped = resampled_df.groupby(['time_est', 'county'])['value'].sum().reset_index()

    # Store aggregated values
    for _, row in grouped.iterrows():
        key = (row['time_est'], row['county'])
        if key in county_time_aggregates:
            county_time_aggregates[key] += row['value']
        else:
            county_time_aggregates[key] = row['value']

# Step 5: Convert aggregated data to a DataFrame
aggregated_df = pd.DataFrame.from_dict(county_time_aggregates, orient='index', columns=['value']).reset_index()
aggregated_df[['time_est', 'county']] = pd.DataFrame(aggregated_df['index'].tolist(), index=aggregated_df.index)
aggregated_df = aggregated_df.drop(columns=['index'])
aggregated_df["state"] = aggregated_df["county"].str[:2]  # Ensure state is available for dissolving

# Step 6: Plot 3x3 grid of heatmaps
fig, axes = plt.subplots(3, 3, figsize=(18, 15), constrained_layout=True)

for i, time_res in enumerate(time_resolutions):
    resampled_df = resample_data(aggregated_df.copy(), time_res)
    
    for j, spatial_res in enumerate(spatial_resolutions):
        # Prepare data for the resolution
        filtered_df = resampled_df.copy()

        # Handle spatial resolution
        if spatial_res == 'state':
            filtered_df = filtered_df.groupby(['time_est', 'state'])['value'].sum().reset_index()
            merged = us_counties.merge(filtered_df, on='state', how='left')
            merged = merged.dissolve(by='state', aggfunc='sum').reset_index()
        elif spatial_res == 'country':
            merged = us_counties.merge(filtered_df, on='county', how='left')
            merged = pd.DataFrame({'value': [merged['value'].sum()]})
        else:  # 'county'
            merged = us_counties.merge(filtered_df, on='county', how='left')

        # Normalize values for heatmap
        avg_value = merged['value'].mean()
        merged['percent_deviation'] = (merged['value'] - avg_value) / avg_value * 100

        # Plot heatmap
        ax = axes[i, j]
        if spatial_res == 'country':
            ax.bar(["US"], [merged['value'][0]], color='blue')
            ax.set_title(f"{spatial_res.capitalize()} | {time_res.capitalize()}")
            ax.set_ylabel("% Deviation")
        else:
            merged.plot(column='percent_deviation', cmap='coolwarm', legend=True, ax=ax,
                        norm=Normalize(vmin=-100, vmax=100))
            ax.set_title(f"{spatial_res.capitalize()} | {time_res.capitalize()}")
            ax.axis('off')

# Global title
fig.suptitle("3x3 Grid Heatmap: Spatial vs Temporal Resolutions", fontsize=16)
plt.show()
