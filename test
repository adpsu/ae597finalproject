import pandas as pd
import geopandas as gpd
import matplotlib.pyplot as plt
from matplotlib.colors import Normalize
import os
import glob

# Load US shapefile for counties
us_counties = gpd.read_file('tl_2019_us_county.shp')  # Replace with actual shapefile path
us_counties['state'] = us_counties['GEOID'].str[:2]
us_counties = us_counties[['GEOID', 'geometry']].rename(columns={'GEOID': 'county'})

# Initialize a dictionary to store aggregated values for each county and time resolution
county_time_aggregates = {}

# Define time resolution function
def resample_data(df, resolution):
    df['time_est'] = pd.to_datetime(df['time_est'])
    if resolution == 'hourly':
        return df
    elif resolution == 'weekly':
        df['time_est'] = df['time_est'].dt.to_period('W').dt.start_time
    elif resolution == 'monthly':
        df['time_est'] = df['time_est'].dt.to_period('M').dt.start_time
    return df

# Path to the folder containing CSVs
csv_folder = '/scratch/county_data'  # Replace with actual path
csv_files = glob.glob(os.path.join(csv_folder, '*.csv'))

# Time and spatial resolutions
time_resolutions = ['hourly', 'weekly', 'monthly']
spatial_resolutions = ['county', 'state', 'country']

# Aggregate data incrementally
for file in csv_files:
    print(f"Processing file: {file}")
    df = pd.read_csv(file)

    # Process each time resolution
    for time_res in time_resolutions:
        df_time_res = resample_data(df.copy(), time_res)

        # Aggregate 'value' for each county and time resolution
        grouped = df_time_res.groupby(['time_est', 'county'])['value'].sum().reset_index()

        # Update the dictionary with aggregated values
        for _, row in grouped.iterrows():
            key = (row['time_est'], row['county'])  # Use (time_est, county) as key
            if key in county_time_aggregates:
                county_time_aggregates[key] += row['value']
            else:
                county_time_aggregates[key] = row['value']

print("Aggregation by time resolution complete.")

# Convert aggregated data into a DataFrame
aggregated_df = pd.DataFrame.from_dict(county_time_aggregates, orient='index', columns=['value']).reset_index()
aggregated_df[['time_est', 'county']] = pd.DataFrame(aggregated_df['index'].tolist(), index=aggregated_df.index)
aggregated_df = aggregated_df.drop(columns=['index'])

# Plot 3x3 grid
fig, axes = plt.subplots(3, 3, figsize=(18, 15), constrained_layout=True)
for i, time_res in enumerate(time_resolutions):
    for j, spatial_res in enumerate(spatial_resolutions):
        # Prepare data for current resolution combination
        filtered_df = aggregated_df.copy()

        # Handle spatial aggregation
        if spatial_res == 'state':
            filtered_df['county'] = filtered_df['county'].astype(str)
            merged = us_counties.merge(filtered_df, on='county', how='left')
            merged = merged.dissolve(by='state', aggfunc='sum').reset_index()
        elif spatial_res == 'country':
            filtered_df['county'] = filtered_df['county'].astype(str)
            merged = us_counties.merge(filtered_df, on='county', how='left')
            merged = pd.DataFrame({'value': [merged['value'].sum()]})
        else:  # 'county'
            filtered_df['county'] = filtered_df['county'].astype(str)
            merged = us_counties.merge(filtered_df, on='county', how='left')

        # Normalize data for plotting
        avg_value = merged['value'].mean()
        merged['percent_deviation'] = (merged['value'] - avg_value) / avg_value * 100

        # Plot heatmap in the grid
        ax = axes[i, j]
        if spatial_res == 'country':
            merged.plot(kind='bar', ax=ax, color='blue', legend=False)
            ax.set_title(f"{spatial_res.capitalize()} | {time_res.capitalize()}")
            ax.set_ylabel("% Deviation")
        else:
            merged.plot(column='percent_deviation', cmap='coolwarm', legend=True, ax=ax,
                        norm=Normalize(vmin=-100, vmax=100))
            ax.set_title(f"{spatial_res.capitalize()} | {time_res.capitalize()}")
            ax.axis('off')

# Set global titles
fig.suptitle("3x3 Grid Heatmap: Spatial vs Temporal Resolutions", fontsize=16)
plt.show()
