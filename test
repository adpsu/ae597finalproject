import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

# Assuming ev_df is already loaded with the appropriate columns
# ev_df = pd.read_csv('path_to_your_data.csv')  # Uncomment and modify with your actual data path
# and_filtered_df = pd.read_csv('path_to_your_benchmark_data.csv')  # Load benchmark data

# Define all Tech types, but benchmarks are only for the last five
tech_types = ['BEV_100', 'BEV_150', 'BEV_200', 'BEV_250', 'BEV_300', 'BEV_350', 'BEV_400', 'BEV_450']
filtered_df = ev_df[ev_df['Tech'].isin(tech_types)]

# Only last five Techs need benchmarks
techs_with_benchmarks = tech_types[-5:]  # Adjust this slice based on your exact needs

def plot_bubble_chart(y_column, title, ylabel):
    plt.figure(figsize=(14, 8))
    ax = plt.gca()
    
    # Mapping each tech type to a numerical index for x-axis positioning
    tech_positions = {tech: i+1 for i, tech in enumerate(tech_types)}
    
    # Plotting benchmark lines for the specified tech types
    for tech in techs_with_benchmarks:
        benchmark = and_filtered_df[and_filtered_df['Tech'] == tech]
        if not benchmark.empty:
            x_position = tech_positions[tech]
            if y_column == 'MSRP':
                ax.axvline(x=x_position, color='red', linestyle='-', linewidth=2)
                ax.text(x_position, benchmark['msrp'].values[0], ' Benchmark', color='red', ha='right')
            else:
                ax.axvline(x=x_position, color='red', linestyle='-', linewidth=2)
                ax.text(x_position, benchmark['fe_comb'].values[0], ' Benchmark', color='red', ha='right')

    # Plotting the data
    for tech in tech_types:
        subset = filtered_df[filtered_df['Tech'] == tech]
        sizes_scaled = subset['total_sales'] / 2  # Scale down the size by half
        scatter = ax.scatter([tech_positions[tech]] * len(subset), subset[y_column], s=sizes_scaled, alpha=0.5, label=tech)

        # Annotate the largest and smallest bubbles
        if not subset.empty:
            largest = subset.loc[subset['total_sales'].idxmax()]
            smallest = subset.loc[subset['total_sales'].idxmin()]
            ax.annotate(largest['Best Match MSRP'], (tech_positions[tech], largest[y_column]), xytext=(40,-10),
                        textcoords="offset points", ha='right', 
                        arrowprops=dict(arrowstyle="->", connectionstyle="angle3,angleA=0,angleB=-90"))
            ax.annotate(smallest['Best Match MSRP'], (tech_positions[tech], smallest[y_column]), xytext=(40,10),
                        textcoords="offset points", ha='right', 
                        arrowprops=dict(arrowstyle="->", connectionstyle="angle3,angleA=0,angleB=90"))

    plt.xticks(range(1, len(tech_types)+1), tech_types)
    plt.xlabel('Technology')
    plt.ylabel(ylabel)
    plt.title(title)
    plt.grid(True)

    # Custom legend for bubble sizes
    sales_values = np.linspace(subset['total_sales'].min(), subset['total_sales'].max(), num=5) / 2
    legend_labels = [f'{int(s*2)}' for s in sales_values]  # Reverse the scaling for display
    handles = [plt.scatter([], [], s=s, label=l, color="gray", alpha=0.5) for s, l in zip(sales_values, legend_labels)]
